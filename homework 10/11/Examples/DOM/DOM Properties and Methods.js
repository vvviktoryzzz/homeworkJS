/***************************
  ПОИСК ЭЛЕМЕНТОВ В ДЕРЕВЕ
***************************/

// Возвращает один элемент
// Поиск возможен только у document
document.getElementById('red');

// Возвращают коллекции элементов
// Поиск возможен и для ранее найденных элементов
var blocks = document.getElementsByClassName('block'),
    block = blocks[0],
    paragraphs = block.getElementsByTagName('p'),
    paragraph = paragraphs[1];

// Первый метод возвращает коллекцию элементов
// Второй метод возвращает только один элемент - первый, подходящий под селектор
// Поиск возможен и для ранее найденных элементов
// Селектор записывается уже с . и # и может быть составным, также возможен поиск по атрибуту
// Эти методы работают дольше, чем getElement(s)By*
// Коллекция, возвращаемая методом querySelectorAll не является живой - не реагирует на добавление/удаление элементов
document.querySelectorAll('div.block#red p');
block.querySelector('p.blue');
var input = blocks[1].querySelector('input[type="text"]');

// (!!!) Если искомые узлы не найдены, то возвращается либо null (если метод предполагал получение одного элемента),
// либо пустую коллекцию (если метод предполагал получение коллекции)

/*****************************
  НАВИГАЦИЯ ПО DOM-ЭЛЕМЕНТАМ
*****************************/

// Возвращает ссылку на корневой элемент - body
document.body;

// Возвращает ссылку на первый дочерний узел (может быть текстовым)
block.firstChild;

// Возвращает ссылку на первый дочерний узел-тег
block.firstElementChild;

// Возвращает ссылку на последний дочерний узел (может быть текстовым)
block.lastChild;

// Возвращает ссылку на последний дочерний узел-тег
block.lastElementChild;

// Возвращает коллекцию из всех дочерних узлов (в т.ч. текстовых)
block.childNodes;

// Возвращает коллекцию из всех дочерних узлов-тегов
block.children;

// Возвращает ссылку на родительский узел (может быть текстовым)
paragraph.parentNode;

// Возвращает ссылку на родительский узел-тег
paragraph.parentElement;

// Возвращает ссылку на ближайшего позиционированного предка (у которого position не равен static), а если такого нет - на body
paragraph.offsetParent;

// Вовзвращает ссылку на следующий сестринский узел (может быть текстовым)
paragraph.nextSibling;

// Вовзвращает ссылку на следующий сестринский узел-тег
paragraph.nextElementSibling;

// Вовзвращает ссылку на предыдущий сестринский узел (может быть текстовым)
paragraph.previousSibling;

// Вовзвращает ссылку на предыдущий сестринский узел-тег
paragraph.previousElementSibling;

// (!!!) Если искомые узлы не найдены, то возвращается либо null (если метод предполагал получение одного элемента),
// либо пустую коллекцию (если метод предполагал получение коллекции)

/********************************
  МАНИПУЛЯЦИЯ ЭЛЕМЕНТАМИ ДЕРЕВА
********************************/

// Создает новый тег "в вакууме", в памяти. У него пока нет ни родителя, ни детей, ни содержимого
// Возвращает этот новый элемент
// Применяется только для document
var newParagraph = document.createElement('p');

// Вставляет элемент в конец списка дочерних элементов у block
// Возвращает вставленный элемент
block.appendChild(newParagraph);

// Вставляет элемент перед каким-нибудь имеющимся дочерним элементом у block
// 1-й параметр - вставляемый элемент, 2-й - перед которым осуществлять вставку
// Возвращает вставленный элемент
block.insertBefore(newParagraph, paragraph);

// Заменяет имеющийся дочерний элемент у block на новый
// 1-й параметр - новый элемент, 2-й - заменяемый элемент
// Возвращает замененный (удаленный) элемент - paragraphs[3]
block.replaceChild(newParagraph, paragraphs[3]);

// Удаляет имеющийся дочерний элемент из списка детей block
// Удалённый элемент продолжает существовать в памяти, но уже не является дочерним для block
// Возвращает удаленный элемент
var removedParagraph = block.removeChild(paragraph);

// Клонирует элемент, копия не привязывается к родительскому элементу div.page-content (parentElement = null)
// Если параметр выставлен в true - клонируются также и дочерние элементы
// Возвращает копию элемента
var clonedBlock = block.cloneNode(true);

// (!!!) Результат выполнения всех вышеперечисленных методов может или местами даже должен быть записан в переменную для
// дальнейшего манипулирования элементами

// Удаляет непосредственно сам элемент
// Ничего не возвращает
block.remove();

/*****************************************
  УПРАВЛЕНИЕ СОДЕРЖИМЫМ ЭЛЕМЕНТОВ ДЕРЕВА
*****************************************/

// Возвращает полное html-содержимое block с текстом
// Как правило, сохраняется в переменную для дальнейшего манипулирования
block.innerHTML;

// Устанавливает html-содержимое (передающееся в виде строки !) в block
// При этом перезаписывается всё предыдущее содержимое block
block.innerHTML = '<span>Привет</span>';

// Добавляет в конец имеющейся разметки новую
block.innerHTML += '<span>Привет</span>';

// Возвращает текстовое содержимое paragraph со всеми пробельными символами
// Как правило, сохраняется в переменную для дальнейшего манипулирования
paragraph.textContent;

// Перезаписывает текст в paragraph на новый
paragraph.textContent = 'Привет';

// Добавляет в конец имеющегося текста новый
paragraph.textContent += 'Привет';

// Возвращает текстовое содержимое paragraph
// Как правило, сохраняется в переменную для дальнейшего манипулирования
paragraph.innerText;

// Перезаписывает текст в paragraph на новый
paragraph.innerText = 'Привет';

// Добавляет в конец имеющегося текста новый
paragraph.innerText += 'Привет';

// (!!!) Лучше работать со свойствами textContent и innerText уже конечного элемента, у которого нет детей, во
// избежание некорректного поведения

// Возвращает значение полей формы
// Как правило, сохраняется в переменную для дальнейшего манипулирования
// Чаще всего применяется для input, textarea
input.value;

// Устанавливает значение полям формы
// При этом перезаписывается предыдущее значение
input.value = 'Привет';

// Добавляет значение в конец имеющегося
input.value += 'Привет';

/************
  КОЛЛЕКЦИИ
************/

// Если DOM-дерево изменяется (напр. удаляются или добавляются элементы) - содержимое HTML-коллекции также изменяется,
// поскольку оно является "живым"
block.remove();
console.log(blocks);

// Однако в случае с методом querySelectorAll() возвращается не совсем коллекция, и она не является "живой", т.е. не
// реагирует на изменения DOM-дерева
paragraphs = document.querySelectorAll('div.block#red p');
paragraphs[2].remove();
console.log(paragraphs);